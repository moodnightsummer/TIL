## 네트워크

### 호스팅

어떤 서비스를 빌려서 사용한다는 의미로, 웹 호스팅이란 외부의 서버를 빌려서 기능을 사용한다는 뜻이다. 웹 호스팅, 서버 호스팅, 클라우드 호스팅이 있다.

#### 웹 호스팅

호스팅 업체의 서버 중 일부만 임대하여 사용
서버 및 인프라 구축이 필요하지 않고 가격이 저렴
단독 서버 사용자에 비해 자원 사용량이 제한되고, 서버 관리 권한이 없다.

#### 서버 호스팅

호스팅 업체의 물리 서버를 단독으로 임대/구매하여 사용하고 서버 운영에 필요한 인프라와 기술력까지 제공받음
서버관리에 대한 직접 권한을 가지고 서버의 모든 자원 활용이 가능하며 서버 단독 사용으로 웹 호스팅과 비교해 보안이 좋음
초기 구축 시간과 비용이 꽤 사용되고 웹 호스팅이나 클라우드에 비해 비쌈

#### 클라우드 호스팅

호스팅 업체의 가상 서버를 단독으로 사용
서버 관리에 대한 직접 권한을 가지고 사용자가 필요할 때 자유롭게 서버 확장/축소 가능하며 서버 호스팅과 비교해 서버 스펙도 조절이 가능하며 이용한만큼 과불됨
하나의 프로그램에 이상이 생기면 연결된 다른 프로그램도 영향을 받아 이중화나 백업 등의 방식으로 커버해야 함

### 웹 통신의 흐름

1. 사용자가 웹 브라우저를 통해 URL을 입력한다.
2. 입력된 URL의 도메인 네임을 DNS 서버에서 검색한다.
3. URL 정보와 DNS 서버로부터 전달받은 IP 주소를 통해 HTTP Request Message를 생성한다.
4. TCP를 통해 서버에 요청한다.
5. 서버는 클라이언트의 요청에 맞는 HTTP Response를 전송한다.

### Nginx

웹 서버의 일종이며 컴퓨터의 정적 리소스(html, css, javascript, image) 등을 클라이언트에게 제공하며, 리버스 프록시를 통해 서버 보안이 가능하고, 로드 밸런싱, 캐싱 기능을 제공한다.

nginx는 이벤트 드리븐 방식으로 작동되어 아파치 등 타 웹 서버보다 성능이 중요시 될 때 사용한다.

event-driven : 시간이 오래 걸리는 요청들을 따로 수행하는 쓰레드 풀을 만들어 worker process는 cpu의 코어 수만큼 생성되고, cpu의 context-switching 사용을 줄일 수 있게 하는 구조. 클라이언트 요청을 병렬 처리로 진행하고 동시 커넥션 양과 속도를 대폭 향상시킨다.

리버스 프록시 : 서버가 클라이언트에게 자신의 서버 정보를 숨기기 위해 사용한다.

로드 밸런싱 : nginx에 여러 대의 서버가 연결되었을 때 균등하게 요청을 분배한다.

프록시 캐싱 : 클라이언트 요청을 받아 백엔드 서버로 전달하기 전에 응답을 캐싱하는 방식이다. 동일한 응답일 경우 다시 생성하지 않고 캐시 된 응답을 반환하여 서버의 부하를 줄일 수 있다.

#### Master Process

설정 파일을 읽고 설정 파일에 맞는 worker process를 생성하는 작업을 한다.

#### Worker Process

실제 요청을 처리하는 작업을 한다.

### HTTP

텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.

#### 특징

- TCP/IP를 이용하는 응용 프로토콜이다.
- 연결 상태를 유지하지 않는 비연결성 프로토콜이다.
- 비연결성 프로토콜이라 요청/응답 방식으로 동작한다.

### TCP/IP

TCP/IP는 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있는데, TCP는 IP 위에서 동작하는 프로토콜로 데이터의 전달을 보증하고 보낸 순서대로 받게 한다. 고로, TCP/IP는 하나의 프로토콜이 아닌 TCP와 IP를 합쳐서 부르는 말이다.

#### IP

인터넷을 통해 데이터를 주고받을 떄 사용되는 통신 규약으로 OSI 7 Layer 중 3계층에 해당한다. IP는 데이터를 패킷 단위로 나누어 전송하고 받는 쪽에서 그 패킷들을 다시 조립하여 원래의 데이터로 변환하는 과정을 거친다.

#### TCP

전송 제어 프로토콜의 약자로 OSI 7 Layer 중 4계층에 해당한다. 통신하고자 하는 양쪽 단말이 통신할 준비가 돼 있는지, 데이터가 제대로 전송되었는지, 데이터가 가는 도중 변질되지 않았는지, 수신자가 얼마나 받았고 빠진 부분은 없는지 등을 점검한다. TCP 헤더에 신뢰성 보장, 흐름제어, 혼잡 제어에 관여할 수 있는 요소들이 포함되어 있다.

#### TCP의 연결 확립 작동 (3-way handshake)

1. A와 B가 있을 때 A는 B에게 SYN을 1로 활성하고 요청을 보낸다.
2. B는 A에게 받은 요청에 대한 응답인 ACK를 1로 활성하고, B 역시 A와 연결 확립을 하기 위해 SYN을 1로 변경하여 응답을 요청한다.
3. A는 B로부터 SYN와 ACK를 받았으니 B가 요청에 응답하기 위해 ACK를 1로 활성하고 B에게 전송한다.

#### TCP의 연결 종료 작동 (4-way handshake)

1. A는 B에게 FIN을 1로 활성하여 종료 요청을 보낸다.
2. B는 A에게 받은 FIN에 대한 응답으로 ACK를 1로 변경하여 보낸다.
3. B 역시 A에게 FIN을 1로 활성하여 종료 요청을 보낸다.
4. A는 B에게 받은 FIN에 대한 응답으로 ACK를 1로 변경하여 보낸다.

#### TCP 특징

- 흐름 제어
  - 송신자는 자신이 한 번에 얼마나 보낼 수 있는지, 수신자는 자신이 데이터를 어디까지 받았는지 끊임없이 확인하고 TCP Header 내의 Window size를 사용해 한 번에 받고 보낼 수 있는 데이터의 양을 정한다.
- 혼잡 제어
  - 데이터가 지나가는 네트워크망의 혼잡 또한 중요하다. 송신자는 연결 초기에 데이터 송출량을 낮게 잡고 보내면서 수신자의 수신을 확인하며 데이터 송출량을 조금씩 늘려가며 현재 네트워크에 가장 적합한 데이터 송출량을 확인한다. 이것이 slow start이다.

### HTTPS

HTTPS는 HTTP에 보안 소켓 레이어가 추가된 것이다. 클라이언트와 서버는 핸드쉐이크를 통해 서버는 인증서를 보내고 클라이언트는 그 인증서를 브라우저에 내장된 인증 기관인 CA에 보내 등록된 인증서인지 확인한다.

클라이언트는 인증 후 사이트의 정보와 서버의 공개 키를 얻게 되고, 이 공개 키로 통신에 사용할 세션 키를 보낸다. 서버는 받은 세션 키를 개인 키로 복호화해 확인하고 이후의 통신은 방금 받은 세션 키를 대칭 키 방식으로 암복호화하여 사용한다.

비대칭 키 방식이 있는데 왜 굳이 복잡하게 핸드쉐이크 후 공개 키로 세션 키를 만들어 서버에 보내고 그것을 복호화하는 과정을 통해 가면서 대칭 키 방식으로 사용하냐면, 비대칭 키 방식은 컴퓨터에 부하가 많이 가기 때문이다.

### REST

URI를 통해 자원을 표시하고 HTTP Method를 이용해 해당 자원의 행위를 정해 주며, 그 결과를 표현하는 것을 의미한다.

#### 특징

1. 유니폼 인터페이스

   표준만 따른다면 어떤 언어 혹은 어떤 플랫폼에서 사용하여도 사용이 가능하다.

2. 무상태성

   상태 정보를 유지하지 않는다.
   서버는 각각의 요청을 완전히 다른 것으로 인식하고 처리한다.
   이전 요청이 다음 요청 처리에 연관되지 않는다.

3. 캐시 가능

   HTTP의 기존 웹 표준을 사용하기 때문에 캐싱 기능을 적용할 수 있다.

4. 클라이언트 - 서버 구조

   서버는 API를 제공하고 클라이언트는 사용자 인증 등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되어 클라이언트와 서버의 역할이 명확하고, 서로 간의 의존성이 줄어든다.
   자원이 있는 곳을 server, 자원을 요청하는 곳이 client가 된다.

5. 자체 표현 구조

   REST API 메시지만 보고도 쉽게 이해가 가능한 자체 표현 구조로 되어 있다.

6. 계층형 구조

   다중 계층으로 구성하여 API 서버는 비즈니스 로직만 처리하고 프록시나 게이트웨이 같은 네트워크 중간 매체를 통해 보안, 로드 밸런싱, 암호화 계층을 따로 둘 수 있다.

### HTTP Method

- GET : 서버에 존재하는 데이터를 요청한다.
- POST : 서버에 데이터를 추가하기 위해 요청한다.
- PUT : 서버에 있는 데이터를 전반적으로 수정하기 위해 요청한다. 존재하지 않는 데이터라면 추가한다.
- PATCH : 서버에 있는 데이터 중 일부를 수정하기 위해 요청한다.
- DELETE : 서버에 있는 데이터를 제거하기 위해 요청한다.

### HTTP Method에서의 멱등성

멱등성이란 동일한 요청을 한 번 보내는 것과 여러 번 보내는 것이 서로 동일한 효과를 지니고, 서버의 상태도 동일하게 남을 때 멱등성을 가진다고 한다.

<b>요청에 대한 서버의 상태가 항상 같은가를 생각해 보아야 한다.</b>

HTTP Method 중 Get, Put, Delete는 멱등성이 보장된다.

Get은 단순히 조회만 하기 때문에 여러 번 수행되어도 결과 값이 변하지 않는다.

Put은 서버에 존재하는 리소스를 요청에 담긴 내용 통째로 수정해 버리기 때문에 올바르게 구현했을 시 여러 번 수행되어도 항상 같은 값으로 수정되기 때문에 멱등하다.

Delete는 존재하는 데이터를 삭제한 결과와 이미 존재하지 않는 결과를 삭제하려는 시도에 따른 응답 코드는 다르지만 서버의 상태는 변하지 않으므로 여러 번 수행되어도 멱등하다.

HTTP Method 중 Post, Patch는 멱등성이 보장되지 않는다.

Post는 동일한 값이어도 계속해서 데이터베이스에 데이터가 추가될 것이고, 이는 멱등성을 위배하는 행위이므로 호출 될 때마다 서버의 상태가 달라진다.

Patch는 멱등성을 보장하도록 설계할 수는 있지만 멱등성을 보장하지 않도록 설계할 수도 있다. 리소스의 일부에 대한 변화를 명령할 수 있기 때문이다. Put과 Patch의 다른 점을 생각해 보면 된다.
