## Operationg System (운영체제)

### 프로세스와 스레드 차이

#### 프로세스

운영체제로부터 자원을 할당받은 작업의 단위로 실행되어 작업 중인 컴퓨터 프로그램을 의미한다.

#### 스레드

프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위이다.

#### 프로세스와 스레드의 흐름

프로세스가 생성되면 운영체제로부터 총 4개의 영역인 stack, heap, code, data 영역이 생성되고, 하나의 프로세스에는 한 개 이상의 스레드가 생성된다. 이때 스레드는 프로세스로부터 stack 영역만 할당받아 생성되고, heap, code, data 영역은 프로세스 내의 영역들로부터 각각의 스레드와 공유하며 사용한다.

#### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

1. 자원 효율성 증대

- 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행하면 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 들어 자원을 효율적으로 관리할 수 있다.
- 스레드는 프로세스 내의 메모리를 공유해 독립적인 프로세스보다 스레드끼리 데이터를 주고받는 것이 간단해지고 시스템 자원 소모가 줄어든다.

2. 처리 비용 감소 및 응답 시간 단축

- 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적게 든다. 이유는 Stack을 제외한 모든 메모리를 공유해서 사용하기 때문이다.
- 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 더 빠르다. 이유는 context switching 시 스레드는 Stack 영역만 처리하기 때문이다.

### Context Switching

Context Switching이란 멀티 프로세스 환경에서 CPU가 하나의 프로세스를 실행하고 있을 때 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업이다.

context란 CPU가 해당 프로세스를 실행하기 위해 필요한 정보들이다.
context는 Process control block에 저장되며, pcb에 저장되는 값들은 프로세스의 상태, 프로그램 카운터, 레지스터, 프로세스의 번호가 저장된다.

컨텍스트 스위칭이 진행될 때 해당 CPU는 아무런 작업을 할 수 없기 때문에 컨텍스트 스위칭이 자주 일어나면 오버헤드가 발생하여 성능이 저하된다.

인터럽트는 CPU가 프로그램을 실행하고 있을 때 실행 중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우 CPU에게 알려 예외 상황을 처리할 수 있도록 하는 것이다.

예외 상황은 입출력 요청, CPU 사용 기간 만료, 자식 프로세스 생성, 인터럽트 처리 대기 시에 발생한다.

### Docker

도커란 컨테이너 기술을 기반으로 한 일종의 가상화 플랫폼이다. 가상화란 물리적 자원인 하드웨어를 효율적으로 사용하기 위해 하드웨어 공간 위에 가상의 머신을 만드는 기술이다.

요약하자면, 독립된 환경을 만들어 하드웨어를 효율적으로 사용하는 기술이라고 볼 수 있다.

#### 도커 이미지

컨테이너를 정의하는 읽기 전용 템플릿이다. 소스 코드, 라이브러리, 종속성, 도구 및 응용 프로그램을 가진다.

#### 도커 컨테이너

도커 이미지로 생성할 수 있고, 컨테이너를 생성하면 호스트와 다른 컨테이너로부터 격리된 시스템 자원 및 네트워크를 사용할 수 있는 프로세스가 생성된다.

같은 도커 이미지로 A와 B 컨테이너를 생성하였어도 A와 B는 서로 영향을 주고받지 않는다. 완벽하게 독립된 공간이다.

#### 장점

<b>환경 일치</b>

다양한 환경에서 동일한 실행 환경을 보장한다. 개발 환경과 운영 환경의 차이로 인한 문제를 방지한다.

<b>편리한 배포</b>

도커 컨테이너는 이미지로 패키징되어 배포되어 어플리케이션 배포가 간단해진다. 이미지를 공유하거나 배포할 때 용이하고, 빠른 확장이 가능하다.

<b>격리된 환경</b>

도커는 각 컨테이너를 격리된 환경으로 실행하여 어느 컨테이너에서 문제가 발생하여도 다른 컨테이너에 영향을 끼치지 않는다.

<b>스케일링</b>

컨테이너 기반 아키텍처는 쉬운 스케일링이 가능해 요구에 따라 응용 프로그램을 확장할 수 있다.

### 입출력

컴퓨터는 필수 장치인 CPU와 메모리, 주변 장치인 입출력(마우스, 키보드 등) 장치와 저장(SSD, HDD) 장치로 구성된다.

각 장치는 메인보드에 있는 버스로 연결된다.

#### 저속 주변 장치

- 메모리와 주변 장치 사이에 오고 가는 데이터 양이 적어서 데이터 전송률이 낮은 장치이다.
- 키보드가 대표적인 예이다.

#### 고속 주변 장치

- 메모리와 주변 장치 사이에 오고 가는 데이터의 양이 많아서 데이터 전송률이 높은 장치이다.
- 그래픽 카드, 하드 디스크가 대표적인 예이다.

#### 입출력 버스의 구조

입출력 버스 구조는 계속해서 바뀌어 왔는데, 컴퓨터 사용 초기에는 주변 장치가 많지 않았고, CPU와 메모리의 속도도 빠르지 않아 모든 장치를 하나의 버스에 연결해도 문제가 없었으나 시간이 지나면서 CPU와 메모리의 성능이 향상되고 주변 장치도 다양해져 하나의 버스만으로 연결하면 문제가 생기기 시작했다.

- 입출력 제어기 도입
- 입출력 버스의 분리

```
기존의 입출력 버스 구조

           CPU               메모리
<---------------------------------------->
                    버스
키보드, 마우스  라인 프린터  플로피디스크  하드디스크



변경된 입출력 버스 구조

  CPU              메모리(MMS)
   |                  |
   |                  |
<-------------------------->
   |                  |
   |                  |
그래픽 카드          입출력 제어기
                   고속 입출력   <------------------------>
                      |         하드 디스크  랜카드  USB 장치
                      |
                   저속 입출력   <------------------------>
                                키보드     마우스     스캐너
```

입출력 제어기가 생겼고, CPU와 주변 장치 간의 데이터 통신을 직접 관리하게 되었다. 이로 인해 CPU와 메모리의 작업이 느려지는 것을 막을 수 있게 되었다.

고속 입출력 장치를 위한 버스와 저속 입출력 장치를 위한 버스가 나뉘었다. 내부에서 나뉘지 않으면 또 느려지기 때문에 분리한 것이다. 데이터 전송을 채널 선택기가 관리해 줘서 두 버스의 데이터 전송 속도를 조절하게 된다.

와중에 그래픽 카드는 따로 관리되고 있는데 그래픽 카드도 주변 장치임에도 CPU의 계산 능력만큼 뛰어난 속도를 가지고 있다. 이를 고속 입출력 버스로 감당할 수 없어 메인 버스에서 CPU, 메모리, 그래픽 카드와 함께 관리한다.

#### 직접 메모리 접근 (DMA)

입출력 제어기는 주변 장치들의 입출력을 대행하고 여러 채널에서 온 데이터를 메모리에 옮기는 역할을 한다. CPU 개입 없이도 메모리에 접근할 수 있도록 입출력 제어기에 DMA라는 권한을 부여해 준다. 입출력 제어기에는 직접 메모리에 접근할 수 있는 DMA 제어기가 추가되어 있는 것이다.

이런 방식은 CPU가 사용하는 작업 공간인 메인 메모리가 DMA 제어기와 공유된다. 현재 입출력 시스템에서는 메인 메모리 공간을 CPU가 작업하는 공간과 DMA 제어기가 데이터를 옮기는 공간으로 분리한다. 이 방식을 memory mapped I/O라고 한다.

memory mapped I/O 방식으로 CPU와 DMA 제어기의 작업 공간이 겹치는 것을 막는다.

#### 인터럽트

주변 장치의 입출력 요구나 하드웨어의 이상 현상 등을 CPU에 알려 주는 역할을 하는 신호이다.
주변 장치에서 생기는 인터럽트를 처리하기 위해 운영체제는 장치에 따라, 인터럽트 성격에 따라 IRQ라는 고유 인터럽트 번호를 부여한다. 이를 통해서 인터럽트가 발생한 IRQ를 확인하고 그에 맞는 인터럽트 처리 루틴을 실행한다.

#### 인터럽트 처리 흐름

인터럽트 발생 -> 인터럽트 벡터 테이블 확인 -> 이때 인터럽트 처리 루틴이 등록된 곳을 살펴 봄 -> 처리 루틴에 따라 처리 -> 인터럽트 복귀

##### 인터럽트 벡터 테이블이란 각 인터럽트에 대해 해당 인터럽트의 처리 루틴이 등록된 메모리 주소가 포인터 형태로 등록되어 있는 테이블이다.

#### 버퍼

속도가 다른 두 장치의 속도 차이를 완화해 주는 역할을 한다. 메모리와 하드 디스크 사이의 속도 차이가 있다. 느린 장치에서 들어오는 데이터를 버퍼에 모아 한꺼번에 이동하면서 속도 차이를 완화시켜 주는 것이다.

CPU가 한 번에 100개를 처리할 수 있는데 디스크는 한 번에 10개씩만 보낸다면 비효율적이기 때문에 버퍼라는 저장 공간을 따로 두어 디스크에서 일정량 이상의 데이터를 버퍼에 보내서 버퍼의 저장 공간이 차면 그때 CPU가 처리하는 방식을 사용해 효율적인 자원 활용을 하는 것이다.
