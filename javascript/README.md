## Javascript

### OOP

Object Oriented Programming의 약자로 객체 지향 프로그래밍이다.

#### 클래스

OOP를 지원하는 언어로는 클래스 기반 언어인 Java, C++ 등등이 있고, 프로토 타입 기반 언어인 Javascript가 있다.

Javascript도 ES6에서 클래스 방식으로 동일한 개념이 생겼지만 class 내부도 prototype으로 구성되어 있다.

#### 객체지향 프로그래밍의 요소

캡슐화, 상속, 추상화, 다형성의 요소가 있다.

- 캡슐화

  - 외부에 따로 속성이나 기능을 하나로 묶어 객체로 정의하고 객체 안에서 정의된 속성은 해당 객체에서만 접근이 가능하다.
  - 캡슐화로 인해 정보의 은닉화가 가능하며, 프로그램의 세부적인 구현을 외부로 드러내지 않도록 감춘다.
  - 모듈 간의 결합도를 떨어뜨려 유지보수가 용이한 코드를 만들 수 있다.

- 상속

  - 부모 객체의 특징을 물려받는다. 부모가 가징 속성, 메서드 등을 상속받아 동일하게 사용하거나 자식이 일부를 변경하여 해당 기능을 재정의하여 사용할 수 있다.

- 추상화

  - 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미한다. 객체들은 공통된 클래스로부터 생성이 되는데, 이때 객체들이 어떤 공통된 특징을 가져야 한다고 정의하는 것이다.

- 다형성
  - 하나의 객체에 여러 타입을 대입할 수 있는 성질을 의미한다. 다형성을 구현하기 위해서는 오버로딩, 오버라이딩이 있다.

### 클로저

클로저는 함수가 선언되었을 때의 렉시컬 환경이다.

```
function outer() {
  const name = 'jaeil';
  outer() // jaeil 출력
  console.log(name); // 에러 발생
}
// 위와 같은 코드에서는 outer가 종료되었기 때문에 name에 더 이상 접근할 수 없다.

function outer() {
    let count = 0;
    return function () {
        count++;
        return count;
    }
}

const getCount = outer();
getCount();
// 위와 같은 코드에서는 outer() 함수가 종료되었지만 클로저의 특성으로 outer 내의 return 되는 함수가 선언될 때 그 주변의 렉시컬 환경과 함께 번들로 묶였기 때문에 참조하지 않아도 선언할 때 이미 묶이게 된다. 그렇기 때문에 getCount 변수로 outer의 count에 접근할 수 있게 된다.

```
