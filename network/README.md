## 네트워크

### 호스팅

어떤 서비스를 빌려서 사용한다는 의미로, 웹 호스팅이란 외부의 서버를 빌려서 기능을 사용한다는 뜻이다. 웹 호스팅, 서버 호스팅, 클라우드 호스팅이 있다.

#### 웹 호스팅

호스팅 업체의 서버 중 일부만 임대하여 사용
서버 및 인프라 구축이 필요하지 않고 가격이 저렴
단독 서버 사용자에 비해 자원 사용량이 제한되고, 서버 관리 권한이 없다.

#### 서버 호스팅

호스팅 업체의 물리 서버를 단독으로 임대/구매하여 사용하고 서버 운영에 필요한 인프라와 기술력까지 제공받음
서버관리에 대한 직접 권한을 가지고 서버의 모든 자원 활용이 가능하며 서버 단독 사용으로 웹 호스팅과 비교해 보안이 좋음
초기 구축 시간과 비용이 꽤 사용되고 웹 호스팅이나 클라우드에 비해 비쌈

#### 클라우드 호스팅

호스팅 업체의 가상 서버를 단독으로 사용
서버 관리에 대한 직접 권한을 가지고 사용자가 필요할 때 자유롭게 서버 확장/축소 가능하며 서버 호스팅과 비교해 서버 스펙도 조절이 가능하며 이용한만큼 과불됨
하나의 프로그램에 이상이 생기면 연결된 다른 프로그램도 영향을 받아 이중화나 백업 등의 방식으로 커버해야 함

### 웹 통신의 흐름

1. 사용자가 웹 브라우저를 통해 URL을 입력한다.
2. 입력된 URL의 도메인 네임을 DNS 서버에서 검색한다.
3. URL 정보와 DNS 서버로부터 전달받은 IP 주소를 통해 HTTP Request Message를 생성한다.
4. TCP를 통해 서버에 요청한다.
5. 서버는 클라이언트의 요청에 맞는 HTTP Response를 전송한다.

### Nginx

웹 서버의 일종이며 컴퓨터의 정적 리소스(html, css, javascript, image) 등을 클라이언트에게 제공하며, 리버스 프록시를 통해 서버 보안이 가능하고, 로드 밸런싱, 캐싱 기능을 제공한다.

nginx는 이벤트 드리븐 방식으로 작동되어 아파치 등 타 웹 서버보다 성능이 중요시 될 때 사용한다.

event-driven : 시간이 오래 걸리는 요청들을 따로 수행하는 쓰레드 풀을 만들어 worker process는 cpu의 코어 수만큼 생성되고, cpu의 context-switching 사용을 줄일 수 있게 하는 구조. 클라이언트 요청을 병렬 처리로 진행하고 동시 커넥션 양과 속도를 대폭 향상시킨다.

리버스 프록시 : 서버가 클라이언트에게 자신의 서버 정보를 숨기기 위해 사용한다.

로드 밸런싱 : nginx에 여러 대의 서버가 연결되었을 때 균등하게 요청을 분배한다.

프록시 캐싱 : 클라이언트 요청을 받아 백엔드 서버로 전달하기 전에 응답을 캐싱하는 방식이다. 동일한 응답일 경우 다시 생성하지 않고 캐시 된 응답을 반환하여 서버의 부하를 줄일 수 있다.

#### Master Process

설정 파일을 읽고 설정 파일에 맞는 worker process를 생성하는 작업을 한다.

#### Worker Process

실제 요청을 처리하는 작업을 한다.

### OSI 7 Layer

OSI 7 계층은 네트워크 통신이 일어나는 과정을 7단계로 나눈 국제 표준화 기구(ISO)에서 정의한 네트워크 표준 모델이다.
각 계층을 지날 때마다 각 계층에서 Header가 붙게되고 수신측은 역순으로 헤더를 분석하게 된다.

1. 물리 계층 : 데이터를 전기 신호로 변경하는 데에 필요한 계층 (리피터, 허브)
2. 데이터 링크 계층 : 네트워크 기기 간의 데이터 전송과 물리 주소를 결정 (스위치, 브릿지, 이더넷)
3. 네트워크 계층 : 한 네트워크에서 다른 네트워크로 데이터 전송 (라우터)
4. 전송 계층 : 신뢰성 있고 정확성 있는 전달을 위한 계층
5. 세션 계층 : 세션 연결, 설정, 해제와 통신 방식을 결정하는 계층 (API, 소켓)
6. 표현 계층 : 문자 코드, 압축, 암호화 등의 방식으로 데이터를 변환하는 계층 (JPEG, MPEG, GIF, ASCII)
7. 응용 계층 : 애플리케이션에 대한 서비스 계층 (HTTP, FTP, SMTP, POP3, IMAP, Telnet)

### HTTP

텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.

#### HTTP 포트 번호

기본 포트 번호는 80이다.

#### 특징

- TCP/IP를 이용하는 응용 프로토콜이다.
- 연결 상태를 유지하지 않는 비연결성 프로토콜이다.
- 비연결성 프로토콜이라 요청/응답 방식으로 동작한다.

### TCP/IP

TCP/IP는 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있는데, TCP는 IP 위에서 동작하는 프로토콜로 데이터의 전달을 보증하고 보낸 순서대로 받게 한다. 고로, TCP/IP는 하나의 프로토콜이 아닌 TCP와 IP를 합쳐서 부르는 말이다.

#### IP

인터넷을 통해 데이터를 주고받을 때 사용되는 통신 규약으로 OSI 7 Layer 중 3계층에 해당한다. IP는 데이터를 패킷 단위로 나누어 전송하고 받는 쪽에서 그 패킷들을 다시 조립하여 원래의 데이터로 변환하는 과정을 거친다.

#### TCP

전송 제어 프로토콜의 약자로 OSI 7 Layer 중 4계층에 해당한다. 통신하고자 하는 양쪽 단말이 통신할 준비가 돼 있는지, 데이터가 제대로 전송되었는지, 데이터가 가는 도중 변질되지 않았는지, 수신자가 얼마나 받았고 빠진 부분은 없는지 등을 점검한다. TCP 헤더에 신뢰성 보장, 흐름제어, 혼잡 제어에 관여할 수 있는 요소들이 포함되어 있다.

#### TCP의 연결 확립 작동 (3-way handshake)

1. A와 B가 있을 때 A는 B에게 SYN을 1로 활성하고 요청을 보낸다.
2. B는 A에게 받은 요청에 대한 응답인 ACK를 1로 활성하고, B 역시 A와 연결 확립을 하기 위해 SYN을 1로 변경하여 응답을 요청한다.
3. A는 B로부터 SYN와 ACK를 받았으니 B가 요청에 응답하기 위해 ACK를 1로 활성하고 B에게 전송한다.

#### TCP의 연결 종료 작동 (4-way handshake)

1. A는 B에게 FIN을 1로 활성하여 종료 요청을 보낸다.
2. B는 A에게 받은 FIN에 대한 응답으로 ACK를 1로 변경하여 보낸다.
3. B 역시 A에게 FIN을 1로 활성하여 종료 요청을 보낸다.
4. A는 B에게 받은 FIN에 대한 응답으로 ACK를 1로 변경하여 보낸다.

#### TCP 특징

- 흐름 제어
  - 송신자는 자신이 한 번에 얼마나 보낼 수 있는지, 수신자는 자신이 데이터를 어디까지 받았는지 끊임없이 확인하고 TCP Header 내의 Window size를 사용해 한 번에 받고 보낼 수 있는 데이터의 양을 정한다.
- 혼잡 제어
  - 데이터가 지나가는 네트워크망의 혼잡 또한 중요하다. 송신자는 연결 초기에 데이터 송출량을 낮게 잡고 보내면서 수신자의 수신을 확인하며 데이터 송출량을 조금씩 늘려가며 현재 네트워크에 가장 적합한 데이터 송출량을 확인한다. 이것이 slow start이다.

### UDP

User Datagram Protocol의 약자로 데이터를 데이터그램 단위로 처리하는 프로토콜이다. 비연결형 프로토콜로 연결을 위해 할당되는 논리적인 경로가 없다. 각각의 패킷이 다른 경로로 전송되고, 패킷은 독립적인 관계를 지니게 된다. 그렇기 때문에 각각의 데이터는 서로 다른 경로로 독립적으로 처리된다.

#### UDP 특징

- 비연결형 서비스로 데이터그램 방식을 제공
- 정보를 주고받을 때 정보를 보내거나 받는다는 신호 절차를 거치지 않음
- UDP 헤더에 CheckSum 필드를 통해 최소한의 오류만 검출
- 신뢰성 낮음
- TCP보다 속도 측면에서 우위

위와 같은 특징들로 신뢰성보다 연속성이 중요한 서비스인 실시간 스트리밍 서비스에 자주 사용된다.

#### UDP 서버의 특징

- 연결이라는 게 없기 때문에 서버 소켓과 클라이언트 소켓의 구분이 없음
- 소켓을 활용해 IP와 PORT를 기반으로 데이터 전송
- 서버와 클라이언트는 1:1, 1:N, N:M 등으로 연결
- 데이터그램 단위로 전송되며 65535바이트로, 크기가 초과되면 잘라서 보냄
- 흐름제어가 없어 패킷이 제대로 전송되었는지 오류가 없는지 확인 불가

### HTTPS

#### HTTPS의 포트 번호

기본 포트는 433이다.

HTTPS는 HTTP에 보안 소켓 레이어가 추가된 것이다. 클라이언트와 서버는 핸드쉐이크를 통해 서버는 인증서를 보내고 클라이언트는 그 인증서를 브라우저에 내장된 인증 기관인 CA에 보내 등록된 인증서인지 확인한다.

클라이언트는 인증 후 사이트의 정보와 서버의 공개 키를 얻게 되고, 이 공개 키로 통신에 사용할 세션 키를 보낸다. 서버는 받은 세션 키를 개인 키로 복호화해 확인하고 이후의 통신은 방금 받은 세션 키를 대칭 키 방식으로 암복호화하여 사용한다.

비대칭 키 방식이 있는데 왜 굳이 복잡하게 핸드쉐이크 후 공개 키로 세션 키를 만들어 서버에 보내고 그것을 복호화하는 과정을 통해 가면서 대칭 키 방식으로 사용하냐면, 비대칭 키 방식은 컴퓨터에 부하가 많이 가기 때문이다.

### REST

URI를 통해 자원을 표시하고 HTTP Method를 이용해 해당 자원의 행위를 정해 주며, 그 결과를 표현하는 것을 의미한다.

#### 특징

1. 유니폼 인터페이스

   표준만 따른다면 어떤 언어 혹은 어떤 플랫폼에서 사용하여도 사용이 가능하다.

2. 무상태성

   상태 정보를 유지하지 않는다.
   서버는 각각의 요청을 완전히 다른 것으로 인식하고 처리한다.
   이전 요청이 다음 요청 처리에 연관되지 않는다.

3. 캐시 가능

   HTTP의 기존 웹 표준을 사용하기 때문에 캐싱 기능을 적용할 수 있다.

4. 클라이언트 - 서버 구조

   서버는 API를 제공하고 클라이언트는 사용자 인증 등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되어 클라이언트와 서버의 역할이 명확하고, 서로 간의 의존성이 줄어든다.
   자원이 있는 곳을 server, 자원을 요청하는 곳이 client가 된다.

5. 자체 표현 구조

   REST API 메시지만 보고도 쉽게 이해가 가능한 자체 표현 구조로 되어 있다.

6. 계층형 구조

   다중 계층으로 구성하여 API 서버는 비즈니스 로직만 처리하고 프록시나 게이트웨이 같은 네트워크 중간 매체를 통해 보안, 로드 밸런싱, 암호화 계층을 따로 둘 수 있다.

### HTTP Method

- GET : 서버에 존재하는 데이터를 요청한다.
- POST : 서버에 데이터를 추가하기 위해 요청한다.
- PUT : 서버에 있는 데이터를 전반적으로 수정하기 위해 요청한다. 존재하지 않는 데이터라면 추가한다.
- PATCH : 서버에 있는 데이터 중 일부를 수정하기 위해 요청한다.
- DELETE : 서버에 있는 데이터를 제거하기 위해 요청한다.

### HTTP Method에서의 멱등성

멱등성이란 동일한 요청을 한 번 보내는 것과 여러 번 보내는 것이 서로 동일한 효과를 지니고, 서버의 상태도 동일하게 남을 때 멱등성을 가진다고 한다.

<b>요청에 대한 서버의 상태가 항상 같은가를 생각해 보아야 한다.</b>

HTTP Method 중 Get, Put, Delete는 멱등성이 보장된다.

Get은 단순히 조회만 하기 때문에 여러 번 수행되어도 결과 값이 변하지 않는다.

Put은 서버에 존재하는 리소스를 요청에 담긴 내용 통째로 수정해 버리기 때문에 올바르게 구현했을 시 여러 번 수행되어도 항상 같은 값으로 수정되기 때문에 멱등하다.

Delete는 존재하는 데이터를 삭제한 결과와 이미 존재하지 않는 결과를 삭제하려는 시도에 따른 응답 코드는 다르지만 서버의 상태는 변하지 않으므로 여러 번 수행되어도 멱등하다.

HTTP Method 중 Post, Patch는 멱등성이 보장되지 않는다.

Post는 동일한 값이어도 계속해서 데이터베이스에 데이터가 추가될 것이고, 이는 멱등성을 위배하는 행위이므로 호출 될 때마다 서버의 상태가 달라진다.

Patch는 멱등성을 보장하도록 설계할 수는 있지만 멱등성을 보장하지 않도록 설계할 수도 있다. 리소스의 일부에 대한 변화를 명령할 수 있기 때문이다. Put과 Patch의 다른 점을 생각해 보면 된다.

### CORS 교차 출처 리소스 공유

Cross-Origin Resource Shating의 약자로 다른 출처의 자원을 공유한다는 의미이다. 추가 HTTP 헤더를 사용해 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려 주는 것이다.

출처가 다르다는 것은 도메인, 하위 도메인, 포트, 프로토콜이 다르다는 의미이다.

https://domain.com:3000/user?query=name&page=1

#### origin 구성

protocol: HTTPS://
host: www.domain.com
port: 3000 (이건 url에서 생략 가능)

#### 동일 출처 정책

Same Origin Policy는 동일한 출처에 대한 정책을 의미하는데, 동일 출처 서버에 있는 리소스는 자유롭게 사용할 수 있지만 다른 출처 서버에 있는 리소스와는 상호작용이 불가능하다는 것이다.

위와 같은 정책이 필요한 이유는 해커가 CSRF나 XSS 등의 해킹 방법으로 개인 정보를 가로채 악용할 수 있기 때문이다.

#### 출처 비교와 차단은 브라우저의 몫

출처를 비교하는 로직은 서버가 아닌 브라우저에 구현되어 있다.

#### 브라우저의 CORS 동작 순서

1. 클라이언트에서 HTTP 요청의 헤더에 Origin 담아서 전달
   1. 기본적으로 웹은 HTTP 프로토콜을 이용해서 서버에 요청을 보냄
   2. 이때 브라우저는 요청 헤더에 Origin이라는 필드에 출처를 담아 보냄
2. 서버는 응답 헤더에 Access-Control-Allow-Origin을 담아 클라이언트로 전달
   1. 서버가 이 요청에 대한 응답을 할 때 응답 헤더에 Acess-Control-Allow-Origin 필드를 추가하고 값으로 소스를 접근하는 것이 허용된 출처 URL을 보냄
3. 클라이언트에서 Origin과 서버가 보내 준 Access-Control-Allow-Origin을 비교
   1. 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내 준 응답의 Access-Control-Allow-Origin을 배교해 보고 차단할지 말지 결정
   2. 유효하지 않은 Origin이라면 응답 버림

### Google을 치면 생기는 일

- 브라우저는 브라우저 캐시, os 캐시, 라우터 캐시에서 도메인의 IP 주소가 있는지 확인한다.
- 캐시에서 ip 주소를 찾을 수 없었다면 DNS 서버에 IP 주소를 요청한다.
- 브라우저가 TCP/IP 프로토콜을 사용해 3-way handshake를 통해 서버에 연결한다.
- 로드 밸런서를 통해 구글 서버들 중 트래픽을 받을 수 있는 서버에 보낸다.
- 웹 서버에 http 요청을 보낸다.
- 서버가 요청을 처리하고 응답을 생성한다.
- 서버가 HTTP 리스폰스를 보낸다.
- 브라우저가 HTML 컨텐츠를 보여준다.

### 세션과 쿠키

HTTP의 특징인 무상태성과 비연결지향을 대처하기 위해 쿠키와 세션을 사용한다. 둘의 가장 큰 차이점은 상태 정보 저장 위치이다.

#### 쿠키

HTTP의 일종으로 사용자가 어떤 웹 사이트를 방문할 때 해당 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.

HTTP에서 클라이언트의 상태 정보를 쿠키 형태로 클라이언트 PC에 저장해 두고 필요할 때 정보를 참조하거나 재사용할 수 있다.

특징으로는,

- Key-Value 쌍으로 구성된다.
- 쿠키 이름, 쿠키 값, 만료 시간, 전송할 도메인명, 전송할 경로, 보안 연결 여부, HTTPOnly로 구성되어 있다.
- 도메인 당 20 개의 쿠키를 가진다.
- 하나의 쿠키는 4KB까지 저장이 가능하다.

세션 관리, 개인화, 트래킹 등의 목적으로 사용한다.

그리고 쿠키는 클라이언트에서 수정할 수 있기 때문에 위변조의 위험이 있다. 그렇기 때문에 쿠키 값을 암호화해야 하고, 민감하거나 중요한 정보는 쿠키에 저장하지 않아야 한다.

#### 세션

일정 시간 동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술이다.

일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 종료하는 시점이다.

특징으로는,

- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.
- 웹 서버에 저장되는 쿠키이다.
- 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되어 쿠키보다 비교적으로 보안이 우수하다.
- 저장 데이터에 제한이 없다. (서버 용량이 허용하는 범위 내에서)
- 각 클라이언트에 고유 세션 ID를 부여하여 클라이언트를 구분하고 클라이언트에 맞는 서비스를 제공할 수 있다.

노출되면 안 되는 보안적으로 중요한 정보들을 서버 내에서 다루기 위해 사용한다.

세션의 내용은 서버에 저장되기 때문에 서버에 부하가 발생할 수 있고, 클라이언트의 브라우저에 저장되는 쿠키에 비해 비교적 속도가 느리다.

##### 고로 쿠키와 세션 둘 다 적재적소에 잘 사용하여야 서버의 부하를 줄이고 성능적으로도 손해를 보지 않을 수 있다.

### 웹 소켓

웹 소켓은 웹 브라우저와 웹 서버 간의 양방향 통신을 지원하는 프로토콜이다. HTTP 프로토콜의 단점 중 하나인 클라이언트에서 서버로 요청을 보내고 서버는 그에 대한 응답을 보내는 단방향 통신을 극복하기 위해 개발되었다. 웹소켓을 통해 실시간으로 데이터를 주고받으며, 서버 또는 클라이언트 측에서 데이터를 보낼 떄 지연 시간을 최소화하고 효율적인 양방향 통신을 구현할 수 있다.

#### 연결 과정

1. 브라우저에서 HTTP 통신을 이용해 서버에 소켓 통시닝 가능한지 요청을 보낸다. 이때 헤더에 소켓을 사용하기 위한 Upgrade, Connection, WebSocket에 대한 정보를 함께 전송한다.

```
GET /chat
Host: https://localhost.chat
Origin: https://localhost.chat
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: ...
Sec-WebSocket-Version: 13
```

2. 서버에서 웹 소켓 통신이 가능하면 서버에서 웹 소켓 통신이 가능하다는 101 상태의 응답을 보낸다. 이때 서버에서는 클라이언트에서 받은 Sec-WebSocket-Key 키 값에 문자를 더한 뒤 그 값을 암호화하여 Sec-WebSocket-Accept로 클라이언트로 응답한다.

```
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: ...
```

3. 이후에는 ws 혹은 wss 프로토콜을 이용해 양방향 통신을 진행한다.

### MQTT

M2M을 기반으로 하는 IoT 개방형 프로토콜로, 경량의 메시징 프로토콜 또는 규칙 세트이다. 최소한의 전력과 리소스로 마이크로 컨트롤러와 같은 IoT와 모바일 어플리케이션 등 통신에 적합하다.

애플리케이션 레이어 프로토콜로, 일반적인 HTTP와 같은 프로토콜과 달리 클라이언트-서버 모델이 아닌 Broker, Publisher, Subscriber 모델로 이루어져 있다.

#### 동작 방식

MQTT 프로토콜은 게시/구독 모델의 원칙을 기반으로 동작한다. 메시지 발신자와 메시지 수신자를 분리하고, 메시지 브로커라는 제 3의 구성 요소가 메시지 발신자와 메시지 수신자 간의 통신을 처리해 준다.

이 브로커가 하는 일은 게시자로부터 수신되는 모든 메시지를 필터링 하고 구독자에게 직접 배포하는 일을 한다.

#### MQTT 구성 요소

1. MQTT 클라이언트
   - MQTT 클라이언트는 서버부터 MQTT 라이브러리를 실행하는 마이크로 컨트롤러에 이르는 모든 디바이스가 될 수 있다.
   - 클라이언트는 메시지를 보내는 경우 게시자 역할을 하고 메시지를 수신하는 경우 수신자 역할을 한다. 기본적으로 네트워크를 통해 MQTT를 사용하여 통신하는 모든 디바이스를 MQTT 클라이언트 디바이스라고 할 수 있다.
2. MQTT 브로커
   - MQTT 브로커는 여러 클라이언트 간의 메시지를 조정하는 백엔드 시스템이다.
   - 브로커는 메시지 수신 및 필터링, 각 메시지를 구독하는 클라이언트 식별, 메시지 전송 등과 같은 작업을 담당한다.
   - MQTT 클라이언트 권한 부여 및 인증을 한다.
   - 추가 분석을 위해 다른 시스템으로 메시지를 전달한다.
   - 누락된 메시지 및 클라이언트 세션을 관리한다.
3. MQTT 연결
   - 클라이언트와 브로커는 MQTT 연결을 사용하여 통신을 시작한다.
   - 클라이언트는 CONNECT 메시지를 MQTT 브로커로 보내 연결을 시작한다. 브로커는 CONNACK 메시지로 응답하여 연결이 설정되었음을 확인한다.
   - MQTT 클라이언트와 브로커는 모두 TCP/IP로 통신한다.
   - 클라이언트는 서로 연결되지 않으며 브로커에만 연결된다.
